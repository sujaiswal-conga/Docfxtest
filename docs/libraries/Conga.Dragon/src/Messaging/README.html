<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Conga.Dragon.Messaging | Composer NextGen </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Conga.Dragon.Messaging | Composer NextGen ">
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/congaengr/CoreApps/blob/master/libraries/Conga.Dragon/src/Messaging/README.md/#L1">
  </head>

  <script type="module">
    import options from './../../../../public/main.js'
    import { init } from './../../../../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../images/conga.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="congadragonmessaging">Conga.Dragon.Messaging</h1>

<p>This module provides support to exchange messages between microservices. It leverages Conga.Platform.Messaging under the hood.</p>
<h2 id="key-features">Key Features</h2>
<ul>
<li>Provides attributes to decorate a class as a message</li>
<li>Automatically takes care of payload transit through extensions</li>
<li>Provides formatters to control how the message members can be formatted for exchange</li>
<li>Provides middleware to plug-in custom processors to modify message</li>
<li>Provides support to wire-up a single message with multi-handlers</li>
<li>Provides control in message handling retry on failures (*)</li>
</ul>
<h2 id="install-the-libraries-from-nuget">Install the libraries from nuget</h2>
<h3 id="from-package-manager-console">From Package Manager Console</h3>
<pre><code class="lang-shell">Install-Package Conga.Dragon.Messaging
Install-Package Conga.Dragon.Messaging.Extensions
</code></pre>
<h3 id="using-net-cli">Using .NET CLI</h3>
<pre><code class="lang-shell">dotnet add package Conga.Dragon.Messaging
dotnet add package Conga.Dragon.Messaging.Extensions
</code></pre>
<p>You can also install the messaging and related libs in one shot by installing <code>Conga.Dragon</code>. Please refer the &quot;Quick Setup&quot; in the README.md file in root.</p>
<h2 id="configuring-the-library-in-your-application">Configuring the library in your application</h2>
<p>appsettings.json</p>
<pre><code class="lang-xml">{
	&quot;LoggerOptions&quot;: {
		&quot;LogType&quot;: &quot;Console&quot;,
		&quot;LogLevel&quot;: &quot;Information&quot;,
		&quot;LogEnable&quot;: &quot;True&quot;
	},
	&quot;ServiceInfo&quot;: {
		&quot;Name&quot;: &quot;MessagingTest&quot;,
		&quot;Namespace&quot;: &quot;Conga.Dragon&quot;,
		&quot;Version&quot;: &quot;v1&quot;
	},
	&quot;OTEL_AGENT_HOST&quot;: &quot;localhost&quot;,
	&quot;MessageProvider&quot;: {
		&quot;Credentials&quot;: {
			&quot;AccessKey&quot;: &quot;test&quot;,
			&quot;SecretKey&quot;: &quot;test&quot;
		},
		&quot;Endpoints&quot;: {
			&quot;TopicEndpoint&quot;: &quot;http://sns.localhost.localstack.cloud:4566&quot;,
			&quot;QueueEndpoint&quot;: &quot;http://sqs.localhost.localstack.cloud:4566&quot;
		}
	},
	&quot;MessagingConfiguration&quot;: {
		&quot;TopicName&quot;: &quot;dragon-test-topic&quot;,
		&quot;QueueName&quot;: &quot;dragon-test-queue&quot;
	},
	&quot;AmazonS3Config&quot;: {
		&quot;Region&quot;: &quot;us-east-1&quot;,
		&quot;DefaultRegion&quot;: &quot;us-east-1&quot;,
		&quot;AuthenticationRegion&quot;: &quot;us-east-1&quot;,
		&quot;ForcePathStyle&quot;: true,
		&quot;UseHttp&quot;: true,
		&quot;ServiceURL&quot;: &quot;http://127.0.0.1:4566&quot;
	},
	&quot;CacheConfig&quot;: {
		&quot;CacheType&quot;: &quot;Disk&quot;,
		&quot;BaseStoragePrefix&quot;: &quot;https://shared-partition-plat-dev.s3-us-east-1.amazonaws.com/&quot;
	},
	&quot;PlatformEndpoints&quot;: {
		&quot;FeatureFlagManagementApiEndPoint&quot;: &quot;https://localhost:7085/&quot;,
		&quot;ObjectDBApiEndPoint&quot;: &quot;https://localhost:7043/&quot;,
		&quot;CacheApiEndPoint&quot;: &quot;https://localhost:7236/&quot;,
		&quot;UserManagementApiEndPoint&quot;: &quot;https://localhost:7016/&quot;,
		&quot;ConfigurationApiEndPoint&quot;: &quot;https://localhost:7069/&quot;,
		&quot;MetadataApiEndPoint&quot;: &quot;https://localhost:44330/&quot;,
		&quot;EmailApiEndPoint&quot;: &quot;https://localhost:7277/&quot;,
		&quot;DocumentApiEndPoint&quot;: &quot;https://localhost:7280/&quot;,
		&quot;LocalizationApiEndPoint&quot;: &quot;https://localhost:7007/&quot;
	},
	&quot;Authentication&quot;: {
		&quot;TokenUrl&quot;: &quot;https://login-dev.congacloud.io/dev/api/v1/auth/connect/token&quot;,
		&quot;ClientId&quot;: &quot;e47a7f3e-7681-4f64-918b-118f14e47827&quot;,
		&quot;ClientSecret&quot;: &quot;6u6KJlk?XttMS48&quot;
	}
}
</code></pre>
<p>In the <code>Program.cs</code> file add the below lines,</p>
<pre><code class="lang-cs">var s3Config = Configuration.GetSection(nameof(AmazonS3Config)).Get&lt;AmazonS3Config&gt;();
var cacheConfig = Configuration.GetSection(nameof(CacheConfig)).Get&lt;CacheConfig&gt;();

services.ConfigureMessaging(Configuration)
        .ConfigureCache(s3Config, cacheConfig);
</code></pre>
<p>In the <code>Startup.cs</code> file, add the below lines in the <code>Configure</code> method.</p>
<pre><code class="lang-cs">public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IMessagingSetup messagingSetup)
{
    ...

    // Configure the cache store.
    messagingSetup.SetupExtensions(_objectCache);

	  // Pass the assemblies to scan for message and handler types.
    messagingSetup.Setup(new MessagingSetupOptions
    {
        Assemblies = new Assembly[] { typeof(DocumentWorkflowRequestMessage).Assembly, typeof(DocumentWorkflowRequestMessageHandler).Assembly }
    });
}
</code></pre>
<h2 id="creating-a-simple-message">Creating a simple message</h2>
<p>Any class that is a message should be decorated with the attribute <code>Message</code>. All members that should be part of the message should
be decorated with <code>MessageMember</code> attribute.</p>
<pre><code class="lang-cs">[Message]
public class GreetingMessage
{
	[MessageMember]
	public string Message { get; set; }
	
	[MessageMember]
	public string From { get; set; }
}
</code></pre>
<h2 id="publishing-a-message">Publishing a message</h2>
<p>You can publish the message using <code>IMessagePublisher</code>.</p>
<pre><code class="lang-cs">private readonly IMessagePublisher _messagePublisher;

// Create message.
var greeting = new GreetingMessage 
{ 
	Message = &quot;Hello Dragon!&quot;,
	From = &quot;Random Guy&quot;
};

// Publish the message.
await _messagePublisher.Publish(greeting, new MessagePublishOptions {
	Receiver = new ReceiverContext(&quot;global&quot;) // Audience name
});
</code></pre>
<p>At the time of publishing you can also pass lot of additional options like <code>CorrelationId</code>, <code>TransactionId</code> and more through <code>MessagePublishOptions</code>.</p>
<h2 id="handling-the-published-message">Handling the published message</h2>
<p>In recieving side, you should have a similar <code>Greeting</code> class.</p>
<p>All message handlers should derive from the base class <code>BaseMessageHandler</code>. By passing the message type as the generic argument the handler is auto-wired
to the message. You can also have multiple handlers to handle a single message.</p>
<pre><code class="lang-cs">public class GreetingMessageHandler : BaseMessageHandler&lt;GreetingMessage&gt;
{
	public Task&lt;HandlerResult&gt; Handle(GreetingMessage message, MessageReceiveOptions receiveOptions)
	{
		Console.WriteLine(message.Message);
		Console.WriteLine(message.From);

		return Task.FromResult(new HandlerResult { Success = true });
	}
}
</code></pre>
<p>The extra information passed during publishing the message in <code>MessagePublishOptions</code> are available in the handler through the <code>MessageReceiveOptions</code> class.</p>
<h2 id="exchanging-payloads">Exchanging payloads</h2>
<p>One of the main benefit of the messaging library is the ability to automatically taking care of exchanging payloads. The library uses <code>Conga.Dragon.Cache</code> for storing the payloads.</p>
<p>Any message member that should be transmitted as payload should be explicitly marked by setting the <code>IsPayload</code> property as <code>true</code>.</p>
<pre><code class="lang-cs">[Message(Name = &quot;upload-document&quot;)]
public class UploadDocumentMessage 
{
	[MessageMember(IsPayload = true)]
	public byte[] DocumentBytes { get; set; }
}
</code></pre>
<p>On publishing the message, the library will automatically store the document in S3 (or similar persistent store) and send the URI to the receiver. At the recieving side the library will automatically read the payload from S3 and assign it to the property.</p>
<p>You can also use the class <code>MessagePayload</code> for transferring payload.</p>
<pre><code class="lang-cs">[Message(Name = &quot;upload-document&quot;)]
public class UploadDocumentMessage 
{
	[MessageMember]
	public MessagePayload DocumentBytes { get; set; }
}
</code></pre>
<pre><code class="lang-cs">var uploadDocumentMessage = new UploadDocumentMessage 
{
	DocumentBytes = new MessagePayload 
	{
		Key = &quot;custom-key&quot;,
		Payload = ...byte array...
	}
};
</code></pre>
<p>Sometimes you need to publish the same payload that is part of same or different messages to different receivers and in that case it is recommended to manually store the payload using the <code>Conga.Dragon.Cache</code> library and send the uri as part of the message member like shown below.</p>
<pre><code class="lang-cs">[Message(Name = &quot;upload-document&quot;)]
public class UploadDocumentMessage 
{
	[MessageMember]
	public string DocumentUri { get; set; }
}
</code></pre>
<p>In the receiving side you can mark the property as payload so it'll be automatically read from the store.</p>
<pre><code class="lang-cs">[Message(Name = &quot;upload-document&quot;)]
public class UploadDocumentMessage 
{
	[MessageMember(Name = &quot;DocumentUri&quot;, IsPayload = true)]
	public byte[] DocumentBytes { get; set; }
}
</code></pre>
<h2 id="formatting-message-members">Formatting message members</h2>
<p>You can send complex object types in message custom formatters. The formatters helps to convert the members into the right format. For example as default you can't easily send an Aspose document as a message member but you can achieve it through a custom formatter.</p>
<pre><code class="lang-cs">[Message(Name = &quot;upload-document&quot;)]
public class UploadDocumentMessage 
{
	[MessageMember(IsPayload = true, Formatter = typeof(DocumentFormatter))]
	public Document Document { get; set; }
}
</code></pre>
<p>This is how your <code>DocumentFormatter</code> class should look like,</p>
<pre><code class="lang-cs">public class DocumentFormatter : BaseDataTypeFormatter&lt;Document, byte[]&gt;
{
	public override Task&lt;byte[]?&gt; Format(Document? data, object[]? formatOptions = null, CancellationToken cancellationToken = default)
	{
		...
	}

	public override Task&lt;Document?&gt; UnFormat(byte[]? data, object[]? formatOptions = null, CancellationToken cancellationToken = default);
	{
		...
	}
}
</code></pre>
<p>In the<code>Format</code> method the class converts the passed document to byte array and in the <code>UnFormat</code> method does the reverse work.</p>
<h2 id="adding-handler-interceptors">Adding handler interceptors</h2>
<p>The library also provides extension point to intercept handlers pre / post invocation. Below is an example of a handler.</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Interceptor that makes sure a message is processed by a single instance at a time.
/// &lt;/summary&gt;
internal class DuplicateCheckInterceptor : IHandlerInterceptor
{
    public HandlerInterceptionMode InterceptionMode =&gt; HandlerInterceptionMode.Pre;

    public async Task&lt;bool&gt; Intercept(InterceptorRequestContext context, Func&lt;Task&lt;bool&gt;&gt; next, CancellationToken cancellationToken = default)
    {
        var serviceProvider = context.ServiceProvider;
        var transactionRepository = (ITransactionRepository)serviceProvider.GetService(typeof(ITransactionRepository))!;
        var isTransactionsRunning = await transactionRepository.IsTransactionRunning(context.ReceiveOptions.CorrelationId!, context.ReceiveOptions.TransactionId!, cancellationToken);

        if (isTransactionsRunning)
        {
            return false;
        }

        return await next();
    }
}
</code></pre>
<p>You can wire-up the interceptor as below,</p>
<pre><code class="lang-cs">public static void SetupExtensions(this IMessagingSetup messagingSetup)
{
	messagingSetup.AddHandlerInterceptor(new DuplicateCheckInterceptor());
}
</code></pre>
<p>You can also add interceptors as attributes for particular handler(s) by extending from <code>InterceptAttribute</code>.</p>
<pre><code class="lang-cs">public class LogHandlerAttribute : InterceptAttribute
{
	public LogHandler(): base(HandlerInterceptionMode.Pre)
  {
  }
	
	public override Task&lt;bool&gt; Intercept(InterceptorRequestContext context, Func&lt;Task&lt;bool&gt;&gt; next, CancellationToken cancellationToken = default)
	{
		// TODO: implement this
	}
}
</code></pre>
<p>Now you can apply the above interceptor to a handler as below,</p>
<pre><code class="lang-cs">[LogHandler(HandlerInterceptionMode.Both)]
public class SampleMessageHandler : BaseMessageHandler&lt;SampleMessage&gt;
{
}
</code></pre>
<h2 id="adding-message-processors">Adding message processors</h2>
<p>Dragon provides extension points that you can plug into the pipeline to control and manipulate the flow if incoming and outgoing messages. The message formatters and payload processors are actually message processors. All message processors directly or in-directly implements the interface <code>IMessageProcessor</code>.</p>
<p>The below example shows how we can attach common attributes to all outgoing messages.</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Auto injects attributes to message that's been published.
/// &lt;/summary&gt;
internal class CommonAttributesInjector : BaseMessageProcessor
{
	/// &lt;summary&gt;
	/// Stores client context.
	/// &lt;/summary&gt;
	public CommonAttributesInjector() : base(&quot;GlobalAttributesInjector&quot;)
	{
	}

	protected override Task&lt;ProcessorResponse&gt; HandleProcessReceive(ProcessorRequest requestContext, CancellationToken cancellationToken = default)
	{
		return Task.FromResult(new ProcessorResponse(requestContext.Message, ProcessResult.Continue));
	}

	protected override Task&lt;ProcessorResponse&gt; HandleProcessSend(ProcessorRequest requestContext, CancellationToken cancellationToken = default)
	{
		var processorResponse = Task.FromResult(new ProcessorResponse(requestContext.Message, ProcessResult.Continue));
		var clientContext = requestContext.ServiceProvider.GetService(typeof(IClientContext)) as IClientContext;
		var messageContextProvider = requestContext.ServiceProvider.GetService(typeof(IMessageContextProvider)) as IMessageContextProvider;
		var messageContext = messageContextProvider?.GetRequestContext();
		var transactionScopeProvider = requestContext.ServiceProvider.GetService(typeof(ITransactionScopeProvider)) as ITransactionScopeProvider;
		var transactionScope = transactionScopeProvider?.GetCurrentTransactionScope();

		var message = requestContext.Message;
		var additionalProps = message.AdditionalProperties;

		if (clientContext != null)
		{
			if (!additionalProps.ContainsKey(&quot;OrganizationId&quot;))
			{
				additionalProps.Add(&quot;OrganizationId&quot;, clientContext.OrganizationId);
			}

			if (!additionalProps.ContainsKey(&quot;OrganizationFriendlyId&quot;))
			{
				additionalProps.Add(&quot;OrganizationFriendlyId&quot;, clientContext.OrganizationFriendlyId);
			}
		}

		if (messageContext != null)
		{
			message.CorrelationId = messageContext.Message.CorrelationId;
		}

		if (transactionScope != null)
		{
			message.TransactionId = transactionScope.Transaction.Id;
		}

		return processorResponse;
	}
}
</code></pre>
<p>You can add the above <code>CommonAttributesInjector</code> to the framework by the below statement.</p>
<pre><code class="lang-cs">public static void SetupExtensions(this IMessagingSetup messagingSetup)
{
	messagingSetup.AddProcessor(new CommonAttributesInjector());
}
</code></pre>
<p>The <code>CommonAttributesInjector</code> already available as part of the Conga.Dragon.Messaging.Extensions and it automatically injects &quot;OrganizationId&quot;, &quot;OrganizationFriendlyId&quot;, &quot;CorrelationId&quot; and &quot;TransactionId&quot; to the outgoing messages.</p>
<h2 id="api-documentation">API Documentation</h2>
<h3 id="message-attribute">Message Attribute</h3>
<p>Transforms the applied class as a message that can be sent to other parties through a message broker system.</p>
<p><code>Name</code> - The name of the message. If not passed, the class name will be considered as the message name.</p>
<p><code>Type</code> - The type of the message.</p>
<p><code>Version</code> - The version of the message.</p>
<p><code>Description</code> - The description of the message.</p>
<h3 id="message-member-attribute">Message Member Attribute</h3>
<p>Marks the applied property inside the message class as a member that'll be passed with the actual message.</p>
<p><code>Name</code> - The optional name of the member. If not passed the property name is taken.</p>
<p><code>Description</code> - The description of the member.</p>
<p><code>IsHeader</code> - True if the property should go to the header. For example, as an attribute in case of AWS SQS.</p>
<p><code>IsRequired</code> - Is the member is required.</p>
<p><code>IsPayload</code> - Setting <code>true</code> will make the property value should be stored as external payload.</p>
<p><code>Formatter</code> - Optional value formatter for the member.</p>
<h3 id="idatatypeformatter">IDataTypeFormatter</h3>
<p>Represents a component that formats or un-formats data.</p>
<p><code>Task&lt;object?&gt; Format(object? data, object[]? formatOptions = null, CancellationToken cancellationToken = default)</code> - Method that formats data for transporation.</p>
<p><code>Task&lt;object?&gt; UnFormat(object? data, object[]? formatOptions = null, CancellationToken cancellationToken = default)</code> - Method that un-formats the data received after transport.</p>
<h3 id="imessagepublisher">IMessagePublisher</h3>
<p>Represents a component that publishes message through the Dragon Messaging system.</p>
<p><code>Task&lt;PublisherResult&gt; Publish&lt;T&gt;(T message, MessagePublishOptions? publishOptions = null, CancellationToken cancellationToken = default)</code> - Method that publishes the passed message through Dragon Messaging system.</p>
<h3 id="messagepublishoptions">MessagePublishOptions</h3>
<p><code>TopicName</code> - The topic to which the message is published.</p>
<p><code>MessageId</code> - Optional message id. If not passed, the system will automatically sets one.</p>
<p><code>Version</code> - Message version.</p>
<p><code>CorrelationId</code> - The id that helps to correlate group of messages related to an operation.</p>
<p><code>TransactionId</code> - Optional transaction id that needs to be included with the message.</p>
<p><code>Status</code> - Optional status that needs to be included with the message.</p>
<p><code>TimeStamp</code> - The optional time the message is published.</p>
<p><code>Sender</code> - The sender details. If not passed the system will read from configuration.</p>
<p><code>Receiver</code> - Single receiver to send the message.</p>
<p><code>Receivers</code> - Collection of receivers to send the message to. If not passed the message will be sent to all audiences.</p>
<p><code>ExtraProperties</code> - Additional properties that has to be sent with message.</p>
<h3 id="receivercontext">ReceiverContext</h3>
<p><code>Channel</code> - The receiver channel name.</p>
<p><code>AdditionalProperties</code> - Additional properties.</p>
<h3 id="sendercontext">SenderContext</h3>
<p><code>SenderName</code> - The sender name.</p>
<p><code>AdditionalProperties</code> - Additional properties.</p>
<h3 id="basemessagehandler">BaseMessageHandler<t></t></h3>
<p>Base class for all message handlers.</p>
<p><code>Task&lt;HandlerResult&gt; Handle(T message, MessageReceiveOptions messageReceiveOptions)</code> - The method that handles the received message.</p>
<h3 id="messagereceiveoptions">MessageReceiveOptions</h3>
<p><code>MessageId</code> - Optional message id. If not passed, the system will automatically sets one.</p>
<p><code>Version</code> - Message version.</p>
<p><code>CorrelationId</code> - The id that helps to correlate group of messages related to an operation.</p>
<p><code>TransactionId</code> - Optional transaction id that needs to be included with the message.</p>
<p><code>Status</code> - Optional status that needs to be included with the message.</p>
<p><code>PublishedTime</code> - The time at which the message is published.</p>
<p><code>ReceivedTime</code> - The time at which the message is received.</p>
<p><code>Sender</code> - The sender details. If not passed the system will read from configuration.</p>
<p><code>ExtraProperties</code> - Additional properties that has to be sent with message.</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li>Conga.Dragon.Messaging.Annotations</li>
</ul>
<h2 id="related-packages">Related Packages</h2>
<ul>
<li>Conga.Dragon.Messaging.Extensions</li>
</ul>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/congaengr/CoreApps/blob/master/libraries/Conga.Dragon/src/Messaging/README.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>